# üìò Caos

O nome do projeto √© **Caos**, inspirado na divindade primordial da mitologia grega que representava o estado original do universo ‚Äî um espa√ßo indefinido de onde tudo surgiu. Assim como o mito, este projeto nasce da desordem para estabelecer uma estrutura clara, escal√°vel e sustent√°vel no desenvolvimento frontend.

Nosso objetivo √© transformar o caos do in√≠cio de um projeto em uma arquitetura bem definida, que favore√ßa consist√™ncia, reuso, modularidade e legibilidade de c√≥digo. A proposta √© permitir que times m√∫ltiplos desenvolvam em paralelo com fluidez e previsibilidade, respeitando conven√ß√µes r√≠gidas, separa√ß√£o de responsabilidades e boas pr√°ticas reconhecidas no ecossistema React.


## üß± Conven√ß√µes Gerais

* Arquivos `index.ts` servem exclusivamente para **expor publicamente os elementos reutiliz√°veis** da camada (molecule, feature, etc.)

  * Nunca implemente l√≥gica ou declare tipos dentro desses arquivos
  * Eles funcionam como uma interface p√∫blica do m√≥dulo para consumo externo

* Arquivos e pastas em **dash-case**

* Nenhum nome pode conter letra mai√∫scula ou caracteres especiais.

* Toda camada tem sufixo obrigat√≥rio em:

  * Nome do arquivo
  * Nome da fun√ß√£o/componente/classe

* Todos os `index.ts` existem apenas para expor publicamente os m√≥dulos daquela camada.

* Tipos globais ficam em `@types/global.d.ts`

* Todos os `Props` incluem `testID?: string`

* O `types.ts` sempre importa `scheme.ts` e `use-case.ts` no topo, **caso existam.**

* O tipo `Props` deve estender `TWithTestID`, salvo exce√ß√µes descritas em `layouts` e `features`.

* `scheme.ts` usa `zod`, e seu tipo √© inferido como `Schema`

* Todos os componentes podem conter uma pasta `partials/`, com arquivos sufixados `.partial`

* Regras globais aplicam-se a todas as camadas do projeto

---

## üìè Princ√≠pios de Design

Adotamos os seguintes princ√≠pios para garantir a qualidade do c√≥digo:

### ‚úÖ SOLID

1. **S**ingle Responsibility Principle ‚Äî Cada m√≥dulo ou classe deve ter uma √∫nica responsabilidade bem definida.
2. **O**pen/Closed Principle ‚Äî Deve ser aberto para extens√£o, mas fechado para modifica√ß√£o.
3. **L**iskov Substitution Principle ‚Äî Subtipos devem poder substituir seus tipos base sem quebrar o comportamento.
4. **I**nterface Segregation Principle ‚Äî Muitas interfaces espec√≠ficas s√£o melhores que uma interface gen√©rica.
5. **D**ependency Inversion Principle ‚Äî Dependa de abstra√ß√µes, nunca de implementa√ß√µes concretas.

### ‚úÖ KISS (Keep It Simple, Stupid)

* Evite complexidade desnecess√°ria. Prefira solu√ß√µes simples e diretas.

### ‚úÖ YAGNI (You Aren‚Äôt Gonna Need It)

* S√≥ implemente o que for **realmente necess√°rio** agora. Evite criar funcionalidades "por precau√ß√£o".

---

## üö´ Code Smells que N√£o Queremos no Nosso Projeto

Estas s√£o as regras do nosso projeto para manter o c√≥digo limpo, organizado e f√°cil de dar manuten√ß√£o. Evitar esses *code smells* √© o nosso compromisso para garantir que o projeto cres√ßa de forma saud√°vel e que todos na equipe consigam trabalhar com prazer. Vamos direto ao ponto:

| Smell                              | Descri√ß√£o                                                                                          |
| ---------------------------------- | -------------------------------------------------------------------------------------------------- |
| **Acesso direto ao DOM**           | N√£o mexa diretamente no DOM. Use o React (ou o framework que adotamos) para cuidar da interface. Isso mant√©m tudo consistente. |
| **Classe grande**                  | Classes que fazem de tudo viram um monstro. Divida em classes menores, cada uma com um prop√≥sito claro. |
| **C√≥digo duplicado**               | C√≥digo repetido √© um convite pra erros. Extraia o que se repete em fun√ß√µes ou componentes reutiliz√°veis. |
| **C√≥digo morto**                   | Aquele trecho que ningu√©m usa? Jogue fora. N√£o precisamos de bagagem extra no projeto. |
| **Coment√°rios explicando c√≥digo complexo** | Se o c√≥digo precisa de um par√°grafo pra explicar, √© hora de simplificar. C√≥digo claro n√£o precisa de legenda. |
| **Conjuntos de dados**             | Par√¢metros que sempre andam juntos? Junte eles num objeto. Fica mais f√°cil de entender e usar. |
| **Fun√ß√£o longa**                   | Fun√ß√µes que parecem um livro? Divida em peda√ßos menores. Cada fun√ß√£o deve fazer uma coisa s√≥, bem feita. |
| **Fun√ß√µes com muitos par√¢metros**  | Fun√ß√£o com uma lista enorme de par√¢metros √© confusa. Agrupe eles num objeto de configura√ß√£o. |
| **Inveja de funcionalidade**       | Uma classe fu√ßando muito nos dados de outra? Deixe a outra fazer o trabalho. Cada um no seu quadrado. |
| **Intimidade inadequada**          | Classes que sabem demais sobre as outras criam depend√™ncias chatas. Reduza essa proximidade. |
| **L√≥gica acoplada √† UI**           | L√≥gica de neg√≥cio n√£o pertence √† camada visual. Coloque ela em arquivos como `use-case.ts`. |
| **Mudan√ßa divergente**             | Um m√≥dulo que muda por mil motivos diferentes est√° errado. Separe por responsabilidade. |
| **Muta√ß√£o de estado direto**       | N√£o altere o estado diretamente. Use os setters dos hooks ou m√©todos de gerenciamento de estado. |
| **Nomes gen√©ricos**                | Nomes como `data` ou `info` n√£o dizem nada. Escolha nomes que mostrem exatamente o que a vari√°vel faz. |
| **Obsess√£o por primitivos**        | Usar s√≥ strings e n√∫meros pra tudo? Crie tipos pr√≥prios (como models) pra dar mais significado ao c√≥digo. |
| **Cadeias de mensagens**           | Evite coisas como `obj.a().b().c()`. Isso √© fr√°gil. Delegue ou encapsule melhor. |
| **Homem do meio**                  | Classes que s√≥ passam recado pra outras n√£o servem pra nada. Corte o intermedi√°rio. |
| **Cirurgia de espingarda**         | Uma mudan√ßa pequena que te obriga a mexer em mil lugares? Isso √© sinal de acoplamento. Refatore. |
| **Generalidade especulativa**      | N√£o crie c√≥digo "pra caso um dia precise". Foque no que realmente usamos agora. |
| **Switch ou ifs com muitos casos** | Condicionais gigantes s√£o dif√≠ceis de manter. Use mapas de objetos ou fun√ß√µes espec√≠ficas. |
| **Campo tempor√°rio**               | Vari√°veis que s√≥ aparecem em casos muito espec√≠ficos? Repense se elas pertencem ali. |
| **M√©todo longo**                   | M√©todos que v√£o longe demais precisam ser divididos. Cada m√©todo deve ter um foco claro. |
| **Acoplamento excessivo**          | M√≥dulos que dependem demais uns dos outros travam o projeto. Reduza essas amarras. |
| **Falta de testes unit√°rios**      | Sem testes, qualquer mudan√ßa √© um salto no escuro. Escreva testes pra garantir que tudo funciona. |

**Inspira√ß√£o**: Essas pr√°ticas foram inspiradas pelas ideias do [*Refactoring Guru*](https://refactoring.guru/pt-br/refactoring/smells), que nos guiou para escrever c√≥digo mais limpo e organizado. Adaptamos tudo para o que funciona melhor no nosso projeto!

## ‚úÖ Boas Pr√°ticas que Queremos no Nosso Projeto

Estas s√£o as regras do nosso projeto para garantir que o c√≥digo seja claro, f√°cil de manter e um prazer de trabalhar. Adotar essas boas pr√°ticas √© o nosso jeito de construir algo que a equipe possa se orgulhar. Vamos ao que importa:

| Pr√°tica                           | Descri√ß√£o                                                                                          |
| --------------------------------- | -------------------------------------------------------------------------------------------------- |
| **Retorno antecipado (Early Return)** | Saia de uma fun√ß√£o assim que souber o resultado. Evite aninhar condi√ß√µes desnecessariamente. |
| **Nomes descritivos**             | Use nomes que explicam o prop√≥sito de vari√°veis, fun√ß√µes e classes. Nada de `temp` ou `x`. |
| **Fun√ß√µes pequenas e focadas**    | Cada fun√ß√£o deve fazer uma coisa s√≥ e fazer bem. Se est√° grande, divida em fun√ß√µes menores. |
| **Encapsulamento de l√≥gica**      | Agrupe l√≥gica relacionada em fun√ß√µes, classes ou m√≥dulos. Evite espalhar regras pelo c√≥digo. |
| **Uso de tipos pr√≥prios**         | Crie modelos ou entidades em vez de usar tipos primitivos soltos. Isso d√° mais contexto ao c√≥digo. |
| **Imutabilidade de estado**       | Evite mudar estados diretamente. Use c√≥pias ou setters para manter o controle e evitar surpresas. |
| **Testes unit√°rios completos**    | Escreva testes para cobrir os casos principais. Isso d√° confian√ßa pra refatorar sem medo. |
| **Separa√ß√£o de camadas**          | Mantenha l√≥gica de neg√≥cio, interface e acesso a dados em camadas separadas. Nada de misturar tudo. |
| **Evitar condicionais complexos** | Substitua *ifs* e *switchs* complicados por mapas, polimorfismo ou fun√ß√µes espec√≠ficas. |
| **Reutiliza√ß√£o de componentes**   | Crie componentes ou fun√ß√µes reutiliz√°veis para evitar duplica√ß√£o e facilitar manuten√ß√£o. |
| **Valida√ß√£o de entrada**          | Sempre valide dados de entrada em fun√ß√µes ou APIs para evitar erros inesperados. |
| **Documenta√ß√£o m√≠nima e clara**   | Documente apenas o que n√£o √© √≥bvio no c√≥digo. Prefira c√≥digo autoexplicativo a coment√°rios longos. |
| **Uso de padr√µes de projeto**     | Aplique padr√µes como Factory, Strategy ou Observer quando fizerem sentido, mas sem exageros. |
| **Controle de erros robusto**     | Trate erros de forma consistente, com mensagens claras e recupera√ß√£o quando poss√≠vel. |
| **Formata√ß√£o consistente**        | Siga as regras de formata√ß√£o do projeto (use linters!). C√≥digo bem formatado √© mais f√°cil de ler. |
| **Evitar depend√™ncias excessivas** | Reduza o acoplamento entre m√≥dulos. Injete depend√™ncias ou use interfaces para flexibilidade. |
| **Revis√£o de c√≥digo regular**     | Fa√ßa code reviews em equipe. Um par de olhos extra sempre ajuda a melhorar a qualidade. |
| **Performance consciente**        | Otimize apenas onde necess√°rio, mas sempre pense no impacto de loops ou opera√ß√µes pesadas. |

**Inspira√ß√£o**: Essas regras foram inspiradas pelas ideias do [*Refactoring Guru*](https://refactoring.guru/pt-br/refactoring/smells), que nos ajudou a pensar em como manter o c√≥digo mais limpo e organizado. Mas aqui, elas s√£o nossas, adaptadas pro que faz sentido no nosso projeto!

Esta arquitetura √© altamente indicada para projetos de **m√©dio a grande porte**, com m√∫ltiplos m√≥dulos, times ou squads. Sua estrutura detalhada promove **consist√™ncia, escalabilidade e manutenibilidade** ao longo do tempo.

---

## üìÇ Estrutura de Pastas

```bash
src/
‚îú‚îÄ‚îÄ atoms/
‚îú‚îÄ‚îÄ molecules/
‚îú‚îÄ‚îÄ organisms/
‚îú‚îÄ‚îÄ templates/
‚îú‚îÄ‚îÄ features/
‚îú‚îÄ‚îÄ layouts/
‚îú‚îÄ‚îÄ particles/
‚îú‚îÄ‚îÄ models/
‚îú‚îÄ‚îÄ entities/
‚îú‚îÄ‚îÄ utils/
‚îú‚îÄ‚îÄ gateways/
‚îú‚îÄ‚îÄ configs/
‚îÇ   ‚îú‚îÄ‚îÄ http/
‚îÇ   ‚îú‚îÄ‚îÄ envs/
‚îÇ   ‚îú‚îÄ‚îÄ tailwind/
‚îÇ   ‚îî‚îÄ‚îÄ lingui/
‚îú‚îÄ‚îÄ schemas/
‚îú‚îÄ‚îÄ test-resources/
‚îÇ   ‚îú‚îÄ‚îÄ mocks/
‚îÇ   ‚îú‚îÄ‚îÄ libs/
‚îÇ   ‚îî‚îÄ‚îÄ others/
‚îú‚îÄ‚îÄ regexp-constants/
‚îú‚îÄ‚îÄ @types/
‚îÇ   ‚îî‚îÄ‚îÄ global.d.ts
```

---

## üß¨ Sufixos e Nomenclatura por Camada

Cada camada possui uma fun√ß√£o clara dentro da arquitetura. A seguir, s√£o descritas com seus respectivos sufixos obrigat√≥rios e exemplos de uso.

| Camada        | Descri√ß√£o                                                                                                           | Arquivo                        | Conte√∫do interno         |
| ------------- | ------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------------------ |
| atoms/        | Elementos b√°sicos e reutiliz√°veis da interface.                                                                     | `button.atom.tsx`              | `ButtonAtom`             |
| molecules/    | Composi√ß√µes de atoms com poss√≠vel l√≥gica local.                                                                     | `modal.molecule.tsx`           | `ModalMolecule`          |
| organisms/    | Composi√ß√µes de mol√©culas com estrutura sem√¢ntica.                                                                   | `profile-header.organism.tsx`  | `ProfileHeaderOrganism`  |
| templates/    | Layouts de exibi√ß√£o visual e intera√ß√£o para features.                                                               | `strategy.template.tsx`        | `StrategyTemplate`       |
| features/     | Representa uma funcionalidade completa. Deve ser prefixada com o m√≥dulo (layout).                                   | `wallet-deposit.feature.tsx`   | `WalletDepositFeature`   |
| layouts/      | Define a navega√ß√£o e os m√≥dulos da aplica√ß√£o.                                                                       | `wallet.layout.tsx`            | `WalletLayout`           |
| particles/    | Services, constants, context e utilit√°rios que podem ser compartilhados entre features.                             | `scroll-button.particle.tsx`   | `ScrollButtonParticle`   |
| models/       | Classes que encapsulam entidades e l√≥gica.                                                                          | `strategy.model.ts`            | `StrategyModel`          |
| entities/     | Tipagens puras de dados, sempre iniciadas com `T`.                                                                  | `strategy.entity.ts`           | `TStrategyEntity`        |
| utils/        | Fun√ß√µes utilit√°rias puras.                                                                                          | `format-date.util.ts`          | `formatDateUtil`         |
| gateways/     | Acesso a APIs externas. Sempre come√ßa com `find-one`, `find-many`, `create` ou `update` e termina com `gateway.ts`. | `find-one-strategy.gateway.ts` | `findOneStrategyGateway` |
| repositories/ | Hook que orquestra m√∫ltiplos gateways. Nunca usar verbos no nome.                                                   | `strategy.repository.ts`       | `useStrategyRepository`  |

> üìå Importante: O nome de `repository` **n√£o deve ser prefixado com verbos** como `find-one`, pois ele pode combinar diversos gateways com diferentes opera√ß√µes. üìå Features devem sempre deixar expl√≠cito seu m√≥dulo (layout) atrav√©s do prefixo, como `wallet-deposit.feature.tsx`, onde `wallet` √© o nome do layout.

---

```bash
modal/
‚îú‚îÄ‚îÄ modal.molecule.tsx
‚îú‚îÄ‚îÄ modal.types.ts
‚îú‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ modal.test.ts
‚îú‚îÄ‚îÄ modal.mock.ts (opcional)
‚îú‚îÄ‚îÄ modal.use-case.ts (opcional / condicional)
‚îú‚îÄ‚îÄ modal.service.ts (opcional / condicional)
‚îú‚îÄ‚îÄ modal.scheme.ts (opcional)
‚îú‚îÄ‚îÄ modal.context.tsx (opcional)
‚îú‚îÄ‚îÄ modal.constant.ts (opcional)
‚îú‚îÄ‚îÄ partials/
‚îÇ   ‚îî‚îÄ‚îÄ modal-header.partial.tsx (opcional)
‚îú‚îÄ‚îÄ _services/
‚îÇ   ‚îî‚îÄ‚îÄ close-modal.service.ts (opcional)
```

> ‚ÑπÔ∏è **Observa√ß√£o**: Uma `molecule` pode conter um `use-case` que orquestra m√∫ltiplos `services`, ou conter apenas um `modal.service.ts` na raiz para l√≥gica mais simples. Se houver m√∫ltiplos servi√ßos, o uso de `use-case` √© obrigat√≥rio.
>
> ‚úÖ Arquivos marcados como (opcional) podem ser inclu√≠dos conforme a complexidade da interface.
> üü® Arquivos marcados como (condicional) s√£o criados apenas se houver necessidade de l√≥gica espec√≠fica, valida√ß√£o ou orquestra√ß√£o de m√∫ltiplos servi√ßos.s√£o criados apenas se um `use-case` ou `scheme` for necess√°rio.

```bash
src/
‚îú‚îÄ‚îÄ atoms/
‚îú‚îÄ‚îÄ molecules/
‚îú‚îÄ‚îÄ organisms/
‚îú‚îÄ‚îÄ templates/
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îî‚îÄ‚îÄ wallet/
‚îÇ       ‚îî‚îÄ‚îÄ wallet.feature.tsx
‚îú‚îÄ‚îÄ layouts/
‚îú‚îÄ‚îÄ particles/
‚îú‚îÄ‚îÄ models/
‚îú‚îÄ‚îÄ entities/
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ format-date.util.ts
‚îÇ   ‚îú‚îÄ‚îÄ format-date.util.spec.ts
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ gateways/
‚îÇ   ‚îú‚îÄ‚îÄ gateway.ts
‚îÇ   ‚îú‚îÄ‚îÄ http.ts
‚îÇ   ‚îú‚îÄ‚îÄ types.ts
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îî‚îÄ‚îÄ strategy.repository.ts
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ env/
‚îÇ   ‚îú‚îÄ‚îÄ http/
‚îÇ   ‚îú‚îÄ‚îÄ tailwind/
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ schemas/
‚îú‚îÄ‚îÄ @types/
‚îÇ   ‚îî‚îÄ‚îÄ global.d.ts
‚îú‚îÄ‚îÄ test-resources/
‚îÇ   ‚îú‚îÄ‚îÄ mocks/
‚îÇ   ‚îú‚îÄ‚îÄ libs/
‚îÇ   ‚îî‚îÄ‚îÄ others/
```

---


### üìÑ Exemplo `modal.types.ts`


```ts
import { schema } from './modal.scheme';
import { useUseCase } from './modal.use-case';

export namespace NModalMolecule {
  export type UseCase = ReturnType<typeof useUseCase>;
  export type Schema = z.infer<typeof schema>; // Typagem do `schema` caso seja necess√°rio ter valida√ß√µes
  export type Props = TWithTestID;
  export type HeaderProps = TWithTestID & { title: string }; // Typagem do `partial` caso exista
}
```

### üìÑ Exemplo `modal-header.partial.tsx`

```tsx
export const HeaderPartial: FC<NModal.HeaderProps> = ({ testID, title }) => (
  <Text testID={`${testID}-header-partial`}>{title}</Text>
);
```

### üìÑ Exemplo de esquema `modal.scheme.ts`

```ts
import { z } from 'zod';

export const schema = z.object({
  name: z.string().min(1),
});
```

---

## üì° Gateway

* Os gateways devem ter prefixo com verbo obrigat√≥rio.
* Os verbos permitidos s√£o: `find-one`, `find-many`, `create`, `update`.
* Sempre usar sufixo `gateway.ts`.
* Exemplo de nome v√°lido: `find-one-strategy.gateway.ts`.

### üìÑ Exemplo `find-one-strategy.gateway.ts`

```ts
import { httpClient } from './http';
import { TStrategyEntity } from '@/entities/strategy.entity';

export const findOneStrategyGateway = async (id: string): Promise<TStrategyEntity> => {
  const { data } = await httpClient.get(`/strategy/${id}`);
  return data;
};
```

---

## üóÇ Repository

* Os reposit√≥rios implementam os gateways.

* S√£o **hooks** (come√ßam com `use`) e podem orquestrar m√∫ltiplos gateways.

* Nunca devem usar os prefixos `find-one`, `find-many`, `create`, `update`.

* Sempre usar sufixo `repository.ts`.

* O nome deve estar em **dash-case**, mas o nome do arquivo √© sempre no formato `nome.repository.ts` (ex: `strategy.repository.ts`).

* Exemplo de nome v√°lido: `strategy.repository.ts`.

* Os reposit√≥rios implementam os gateways.

* S√£o **hooks** (come√ßam com `use`) e podem orquestrar m√∫ltiplos gateways.

* Sempre usar sufixo `repository.ts`.

---

### üìÑ Exemplo `strategy.repository.ts`

```ts
import { findOneStrategyGateway } from '@/gateways/find-one-strategy.gateway';
import { StrategyModel } from '@/models/strategy.model';

export const useStrategyRepository = () => {

 const findOneById = (id: string) => {
   const data = await findOneStrategyGateway(id);
   return new StrategyModel(data);
 };

 return {
  findOneById
 }
};
```

---

## üß™ Testes

### üìÑ Modelo de teste

```ts
const HocTemplate = (): React.JSX.Element => <Template testID="template" />;

describe('Page: <Template/>', () => {
  it('deve renderizar', async () => {
    render(<HocTemplate />);
    await act(async () => {
      const sut = screen.getByTestId('template');
      expect(sut).toBeTruthy();
    });
  });
});
```

---

## üß≠ Recomenda√ß√£o Final

Use esta documenta√ß√£o como base para todas as decis√µes arquiteturais do projeto.
Respeitar a estrutura proposta ajuda na escalabilidade, manutenibilidade e produtividade do time.

Caso uma exce√ß√£o precise ser feita, **documente** o motivo e compartilhe com o time.

